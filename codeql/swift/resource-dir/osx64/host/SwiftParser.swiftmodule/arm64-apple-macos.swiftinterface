// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.9 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-macosx13.0 -enable-objc-interop -enable-library-evolution -module-link-name SwiftParser -swift-version 5 -O -module-abi-name CompilerSwiftParser -module-name SwiftParser -package-name Toolchain
import Swift
import SwiftSyntax
import _Concurrency
import _SwiftConcurrencyShims
extension SwiftSyntax.AccessorDeclListSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.AccessorDeclListSyntax
}
extension SwiftSyntax.AttributeListSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.AttributeListSyntax
}
extension SwiftSyntax.CodeBlockItemListSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.CodeBlockItemListSyntax
}
extension SwiftSyntax.MemberBlockItemListSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.MemberBlockItemListSyntax
}
extension SwiftSyntax.ExprSyntax {
  public var interpretedAsVersionTuple: SwiftSyntax.VersionTupleSyntax? {
    get
  }
}
public typealias ReusedNodeCallback = (_ node: SwiftSyntax.Syntax) -> ()
final public class IncrementalParseTransition {
  @available(*, deprecated, message: "Use initializer taking `IncrementalParseResult` instead")
  public init(previousTree: SwiftSyntax.SourceFileSyntax, edits: SwiftParser.ConcurrentEdits, lookaheadRanges: SwiftParser.LookaheadRanges, reusedNodeCallback: SwiftParser.ReusedNodeCallback? = nil)
  public init(previousIncrementalParseResult: SwiftParser.IncrementalParseResult, edits: SwiftParser.ConcurrentEdits, reusedNodeCallback: SwiftParser.ReusedNodeCallback? = nil)
  @objc deinit
}
public struct ConcurrentEdits : Swift.Sendable {
  public let edits: [SwiftSyntax.SourceEdit]
  public init(concurrent: [SwiftSyntax.SourceEdit]) throws
  public init(fromSequential sequentialEdits: [SwiftSyntax.SourceEdit])
  public init(_ single: SwiftSyntax.SourceEdit)
  public static func _isValidConcurrentEditArray(_ edits: [SwiftSyntax.SourceEdit]) -> Swift.Bool
}
public enum IdentifierCheckContext {
  case variableName
  case memberAccess
  public static func == (a: SwiftParser.IdentifierCheckContext, b: SwiftParser.IdentifierCheckContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.String {
  public func isValidSwiftIdentifier(for context: SwiftParser.IdentifierCheckContext) -> Swift.Bool
}
public struct Parser {
  public var lookaheadRanges: SwiftParser.LookaheadRanges {
    get
  }
  public init(_ input: Swift.String, maximumNestingLevel: Swift.Int? = nil, parseTransition: SwiftParser.IncrementalParseTransition? = nil, swiftVersion: SwiftParser.Parser.SwiftVersion? = nil)
  public init(_ input: Swift.UnsafeBufferPointer<Swift.UInt8>, maximumNestingLevel: Swift.Int? = nil, parseTransition: SwiftParser.IncrementalParseTransition? = nil, arena: SwiftSyntax.ParsingSyntaxArena? = nil, swiftVersion: SwiftParser.Parser.SwiftVersion? = nil)
}
public struct LookaheadTracker {
  public init()
}
public struct LookaheadRanges : Swift.Sendable {
  public init()
}
extension SwiftParser.Parser {
  public static func parse(source: Swift.String) -> SwiftSyntax.SourceFileSyntax
  public static func parse(source: Swift.UnsafeBufferPointer<Swift.UInt8>, maximumNestingLevel: Swift.Int? = nil, swiftVersion: SwiftParser.Parser.SwiftVersion? = nil) -> SwiftSyntax.SourceFileSyntax
  @available(*, deprecated, message: "Use parseIncrementally with `IncrementalParseResult` return instead")
  @_disfavoredOverload public static func parseIncrementally(source: Swift.String, parseTransition: SwiftParser.IncrementalParseTransition?) -> (tree: SwiftSyntax.SourceFileSyntax, lookaheadRanges: SwiftParser.LookaheadRanges)
  @available(*, deprecated, message: "Use parseIncrementally with `IncrementalParseResult` return instead")
  @_disfavoredOverload public static func parseIncrementally(source: Swift.UnsafeBufferPointer<Swift.UInt8>, maximumNestingLevel: Swift.Int? = nil, parseTransition: SwiftParser.IncrementalParseTransition?) -> (tree: SwiftSyntax.SourceFileSyntax, lookaheadRanges: SwiftParser.LookaheadRanges)
  public static func parseIncrementally(source: Swift.String, parseTransition: SwiftParser.IncrementalParseTransition?) -> SwiftParser.IncrementalParseResult
  public static func parseIncrementally(source: Swift.UnsafeBufferPointer<Swift.UInt8>, maximumNestingLevel: Swift.Int? = nil, parseTransition: SwiftParser.IncrementalParseTransition?) -> SwiftParser.IncrementalParseResult
}
public struct IncrementalParseResult : Swift.Sendable {
  public let tree: SwiftSyntax.SourceFileSyntax
  public let lookaheadRanges: SwiftParser.LookaheadRanges
  public init(tree: SwiftSyntax.SourceFileSyntax, lookaheadRanges: SwiftParser.LookaheadRanges)
}
extension SwiftSyntax.StringLiteralExprSyntax {
  public var representedLiteralValue: Swift.String? {
    get
  }
}
extension SwiftParser.Parser {
  public enum SwiftVersion : Swift.Comparable, Swift.Sendable {
    case v4
    case v5
    case v6
    public static func < (a: SwiftParser.Parser.SwiftVersion, b: SwiftParser.Parser.SwiftVersion) -> Swift.Bool
    public static func == (a: SwiftParser.Parser.SwiftVersion, b: SwiftParser.Parser.SwiftVersion) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol SyntaxParseable : SwiftSyntax.SyntaxProtocol {
  static func parse(from parser: inout SwiftParser.Parser) -> Self
}
extension SwiftSyntax.AccessorBlockSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.AccessorBlockSyntax
}
extension SwiftSyntax.AccessorDeclSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.AccessorDeclSyntax
}
extension SwiftSyntax.AttributeSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.AttributeSyntax
}
extension SwiftSyntax.CatchClauseSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.CatchClauseSyntax
}
extension SwiftSyntax.ClosureParameterSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.ClosureParameterSyntax
}
extension SwiftSyntax.CodeBlockItemSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.CodeBlockItemSyntax
}
extension SwiftSyntax.CodeBlockSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.CodeBlockSyntax
}
extension SwiftSyntax.DeclSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.DeclSyntax
}
extension SwiftSyntax.EnumCaseParameterSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.EnumCaseParameterSyntax
}
extension SwiftSyntax.ExprSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.ExprSyntax
}
extension SwiftSyntax.FunctionParameterSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.FunctionParameterSyntax
}
extension SwiftSyntax.GenericParameterClauseSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.GenericParameterClauseSyntax
}
extension SwiftSyntax.MemberBlockSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.MemberBlockSyntax
}
extension SwiftSyntax.PatternSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.PatternSyntax
}
extension SwiftSyntax.SourceFileSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.SourceFileSyntax
}
extension SwiftSyntax.StmtSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.StmtSyntax
}
extension SwiftSyntax.SwitchCaseSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.SwitchCaseSyntax
}
extension SwiftSyntax.TypeSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.TypeSyntax
}
extension SwiftSyntax.VersionTupleSyntax : SwiftParser.SyntaxParseable {
  public static func parse(from parser: inout SwiftParser.Parser) -> SwiftSyntax.VersionTupleSyntax
}
extension SwiftParser.IdentifierCheckContext : Swift.Equatable {}
extension SwiftParser.IdentifierCheckContext : Swift.Hashable {}
extension SwiftParser.Parser.SwiftVersion : Swift.Hashable {}
