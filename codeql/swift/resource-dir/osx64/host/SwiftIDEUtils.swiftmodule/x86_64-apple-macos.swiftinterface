// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.9 clang-1600.0.30.1)
// swift-module-flags: -target x86_64-apple-macosx13.0 -enable-objc-interop -enable-library-evolution -module-link-name SwiftIDEUtils -swift-version 5 -O -module-abi-name CompilerSwiftIDEUtils -module-name SwiftIDEUtils -package-name Toolchain
import Swift
import SwiftDiagnostics
import SwiftParser
import SwiftSyntax
import _Concurrency
import _SwiftConcurrencyShims
extension SwiftIDEUtils.SyntaxClassification {
  @available(*, deprecated, renamed: "ifConfigDirective")
  public static var poundDirective: SwiftIDEUtils.SyntaxClassification {
    get
  }
  @available(*, deprecated, renamed: "ifConfigDirective")
  public static var buildConfigId: SwiftIDEUtils.SyntaxClassification {
    get
  }
  @available(*, deprecated, message: "String interpolation anchors are now classified as .none")
  public static var stringInterpolationAnchor: SwiftIDEUtils.SyntaxClassification {
    get
  }
  @available(*, deprecated, renamed: "type")
  public static var typeIdentifier: SwiftIDEUtils.SyntaxClassification {
    get
  }
  @available(*, deprecated, renamed: "operator")
  public static var operatorIdentifier: SwiftIDEUtils.SyntaxClassification {
    get
  }
  @available(*, deprecated, renamed: "floatLiteral")
  public static var floatingLiteral: SwiftIDEUtils.SyntaxClassification {
    get
  }
}
extension SwiftSyntax.SyntaxProtocol {
  public var classifications: SwiftIDEUtils.SyntaxClassifications {
    get
  }
  public func classifications(in range: Swift.Range<SwiftSyntax.AbsolutePosition>) -> SwiftIDEUtils.SyntaxClassifications
  @available(*, deprecated, message: "Use classification(at: AbsolutePosition) instead.")
  public func classification(at offset: Swift.Int) -> SwiftIDEUtils.SyntaxClassifiedRange?
  public func classification(at position: SwiftSyntax.AbsolutePosition) -> SwiftIDEUtils.SyntaxClassifiedRange?
}
public enum SyntaxClassification : Swift.Sendable {
  case attribute
  case blockComment
  case docBlockComment
  case docLineComment
  case dollarIdentifier
  case editorPlaceholder
  case floatLiteral
  case identifier
  case ifConfigDirective
  case integerLiteral
  case keyword
  case lineComment
  case none
  case `operator`
  case regexLiteral
  case stringLiteral
  case type
  case argumentLabel
  public static func == (a: SwiftIDEUtils.SyntaxClassification, b: SwiftIDEUtils.SyntaxClassification) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwiftSyntax.TokenSyntax {
  public var tokenClassification: SwiftIDEUtils.SyntaxClassifiedRange {
    get
  }
}
public struct SyntaxClassifiedRange : Swift.Equatable, Swift.Sendable {
  public var kind: SwiftIDEUtils.SyntaxClassification
  public var range: Swift.Range<SwiftSyntax.AbsolutePosition>
  @available(*, deprecated, message: "Use range.lowerBound.utf8Offset instead")
  public var offset: Swift.Int {
    get
  }
  @available(*, deprecated, message: "Use range.utf8Length instead")
  public var length: Swift.Int {
    get
  }
  @available(*, deprecated, message: "Use range.upperBound.utf8Offset instead")
  public var endOffset: Swift.Int {
    get
  }
  public static func == (a: SwiftIDEUtils.SyntaxClassifiedRange, b: SwiftIDEUtils.SyntaxClassifiedRange) -> Swift.Bool
}
public struct SyntaxClassifications : Swift.Sequence, Swift.Sendable {
  public typealias Iterator = Swift.Array<SwiftIDEUtils.SyntaxClassifiedRange>.Iterator
  public init(_ node: SwiftSyntax.Syntax, in range: Swift.Range<SwiftSyntax.AbsolutePosition>)
  public func makeIterator() -> SwiftIDEUtils.SyntaxClassifications.Iterator
  public typealias Element = Swift.IndexingIterator<Swift.Array<SwiftIDEUtils.SyntaxClassifiedRange>>.Element
}
extension SwiftIDEUtils.SyntaxClassification : Swift.Equatable {}
extension SwiftIDEUtils.SyntaxClassification : Swift.Hashable {}
